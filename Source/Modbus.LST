C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN Modbus.OBJ
COMPILER INVOKED BY: D:\Keil C51\C51\BIN\C51.EXE Modbus.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********************************************************************************
   2          * 【说    明】： 此程序为51单片机与MCGS组态王软件Modbus RTU通讯下位机程序，
   3                           此程序在STC89C52RC单片机上测试通过，可以移植到其他51系列单片机！
   4          * 【函数功能】： 51单片机与MCGS组态王软件Modbus RTU通讯主程序                                                                               
   5          * 【修    改】： DREAKER Bluster
   6          * 【修改时间】： 2017年 7月1日
   7          **********************************************************************************/
   8          #include "Project.h"
   9          
  10          sbit LED0 = P1^0; // 对应线圈0
  11          sbit LED1 = P1^1; // 对应线圈1
  12          sbit LED2 = P1^2; // 对应线圈2
  13          sbit LED3 = P1^3; // 对应线圈3
  14          sbit LED4 = P1^4; // 对应线圈4
  15          sbit LED5 = P1^5; // 对应线圈5
  16          sbit LED6 = P1^6; // 对应线圈6
  17          sbit LED7 = P1^7; // 对应线圈7
  18          
  19          sbit KEY0 = P3^2; 
  20          sbit KEY1 = P3^3; 
  21          sbit KEY2 = P3^4; 
  22          sbit KEY3 = P3^5;
  23           
  24          //字地址 0 - 255 (只取低8位)
  25          //位地址 0 - 255 (只取低8位)
  26          
  27          /* CRC 高位字节值表 */
  28          const UINT8 code auchCRCHi[] = {
  29                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  30                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  31                  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  32                  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  33                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
  34                  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  35                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
  36                  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  37                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  38                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
  39                  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
  40                  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  41                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  42                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
  43                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  44                  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  45                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  46                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  47                  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  48                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  49                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  50                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
  51                  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
  52                  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  53                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  54                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
  55          } ;
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 2   

  56          
  57          // CRC低位字节值表
  58          const UINT8 code auchCRCLo[] = {
  59                  0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
  60                  0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
  61                  0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
  62                  0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
  63                  0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
  64                  0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
  65                  0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
  66                  0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
  67                  0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
  68                  0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
  69                  0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
  70                  0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
  71                  0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
  72                  0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
  73                  0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
  74                  0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
  75                  0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
  76                  0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
  77                  0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
  78                  0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
  79                  0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
  80                  0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
  81                  0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
  82                  0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
  83                  0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
  84                  0x43, 0x83, 0x41, 0x81, 0x80, 0x40
  85          } ;
  86          
  87          UINT8   testCoil;       //用于测试 位地址1
  88          
  89          UINT8   localAddr = 1;  //单片机控制板的地址
  90          
  91          UINT16 testRegister0,   // 测试寄存器
  92                                  testRegister1,
  93                                  testRegister2,
  94                                  testRegister3,//存放当前温度
  95                                  testRegister4,//读写寄存器  控制P1口输出
  96                                  testRegister5,
  97                                  testRegister6,
  98                                  testRegister7,
  99                                  testRegister8,
 100                                  testRegister9;
 101          
 102          
 103          
 104          
 105          UINT16 crc16(const UINT8 *puchMsg, UINT16 usDataLen)
 106          {
 107   1              UINT8 uchCRCHi = 0xFF ; /* 高CRC字节初始化 */
 108   1              UINT8 uchCRCLo = 0xFF ; /* 低CRC 字节初始化 */
 109   1              UINT32 uIndex ; /* CRC循环中的索引 */
 110   1      
 111   1              while (usDataLen--) { /* 传输消息缓冲区 */
 112   2                      uIndex = uchCRCHi ^ *puchMsg++ ; /* 计算CRC */
 113   2                      uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ;
 114   2                      uchCRCLo = auchCRCLo[uIndex] ;
 115   2              }
 116   1      
 117   1              return (uchCRCHi << 8 | uchCRCLo) ;
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 3   

 118   1      }
 119          
 120          //开始发送
 121          void beginSend(void)
 122          {
 123   1              UartSendBytes (sendBuf, sendCount);
 124   1      }
 125          
 126          //读线圈状态
 127          void readCoil(void)
 128          {
 129   1              UINT8 addr;
 130   1              UINT8 tempAddr;
 131   1              UINT8 byteCount;
 132   1              UINT8 bitCount;
 133   1              UINT16 crcData;
 134   1              UINT8 position;
 135   1              UINT8 i, k;
 136   1              UINT16 tempData;
 137   1              UINT8  exit = 0;
 138   1      
 139   1              //addr = (receBuf[2]<<8) + receBuf[3];
 140   1              //tempAddr = addr & 0xfff;
 141   1              addr = receBuf[3];
 142   1              tempAddr = addr;
 143   1      
 144   1              //bitCount = (receBuf[4]<<8) + receBuf[5];  //读取的位个数
 145   1              bitCount = receBuf[5];
 146   1      
 147   1              byteCount = bitCount / 8;                   //字节个数
 148   1              if (bitCount % 8 != 0)
 149   1                      byteCount++;
 150   1      
 151   1              for (k = 0; k < byteCount; k++) {
 152   2                      //字节位置
 153   2                      position = k + 3;
 154   2                      sendBuf[position] = 0;
 155   2                      for (i = 0; i < 8; i++) {
 156   3                              getCoilVal(tempAddr, &tempData);
 157   3      
 158   3                              sendBuf[position] |= (tempData << i);
 159   3                              tempAddr++;
 160   3                              if (tempAddr >= addr + bitCount) {
 161   4                                      //读完
 162   4                                      exit = 1;
 163   4                                      break;
 164   4                              }
 165   3                      }
 166   2                      if (exit == 1)
 167   2                              break;
 168   2              }
 169   1      
 170   1              sendBuf[0] = localAddr;
 171   1              sendBuf[1] = 0x01;
 172   1              sendBuf[2] = byteCount;
 173   1              byteCount += 3;
 174   1              crcData = crc16(sendBuf, byteCount);
 175   1              sendBuf[byteCount] = crcData >> 8;
 176   1              byteCount++;
 177   1              sendBuf[byteCount] = crcData & 0xff;
 178   1              sendCount = byteCount + 1;
 179   1      
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 4   

 180   1              beginSend();
 181   1      }
 182          
 183          
 184          //读寄存器
 185          void readRegisters(void)
 186          {
 187   1              UINT8 addr;
 188   1              UINT8 tempAddr;
 189   1              UINT16 crcData;
 190   1              UINT8 readCount;
 191   1              UINT8 byteCount;
 192   1              UINT16 i;
 193   1              UINT16 tempData = 0;
 194   1      
 195   1              //addr = (receBuf[2]<<8) + receBuf[3];
 196   1              //tempAddr = addr & 0xfff;
 197   1              addr = receBuf[3];
 198   1              tempAddr = addr;
 199   1      
 200   1              //readCount = (receBuf[4]<<8) + receBuf[5]; //要读的个数
 201   1              readCount = receBuf[5];
 202   1      
 203   1              byteCount = readCount * 2;
 204   1      
 205   1              for (i = 0; i < byteCount; i += 2, tempAddr++) {
 206   2                      getRegisterVal(tempAddr, &tempData);
 207   2                      sendBuf[i+3] = tempData >> 8;
 208   2                      sendBuf[i+4] = tempData & 0xff;
 209   2              }
 210   1      
 211   1              sendBuf[0] = localAddr;
 212   1              sendBuf[1] = 3;
 213   1              sendBuf[2] = byteCount;
 214   1              byteCount += 3;
 215   1              crcData = crc16(sendBuf, byteCount);
 216   1              sendBuf[byteCount] = crcData >> 8;
 217   1              byteCount++;
 218   1              sendBuf[byteCount] = crcData & 0xff;
 219   1      
 220   1              sendCount = byteCount + 1;
 221   1      
 222   1              beginSend();
 223   1      }//void readRegisters(void)
 224          
 225          //强制单个线圈
 226          void forceSingleCoil(void)
 227          {
 228   1              UINT8 addr;
 229   1              UINT8 tempAddr;
 230   1              UINT16 tempData;
 231   1              UINT8  onOff;
 232   1              UINT8 i;
 233   1      
 234   1              //addr = (receBuf[2]<<8) + receBuf[3];
 235   1              //tempAddr = addr & 0xfff;
 236   1              addr = receBuf[3];
 237   1              tempAddr = addr;
 238   1      
 239   1              //onOff = (receBuf[4]<<8) + receBuf[5];
 240   1              onOff = receBuf[4];
 241   1      
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 5   

 242   1              //if(onOff == 0xff00)
 243   1              if (onOff == 0xff) {
 244   2                      //设为ON
 245   2                      tempData = 1;
 246   2              }
 247   1              //else if(onOff == 0x0000)
 248   1              else if (onOff == 0x00) {
 249   2                      //设为OFF
 250   2                      tempData = 0;
 251   2              }
 252   1      
 253   1              setCoilVal(tempAddr, tempData);
 254   1      
 255   1              for (i = 0; i < receCount; i++) {
 256   2                      sendBuf[i] = receBuf[i];
 257   2              }
 258   1              sendCount = receCount;
 259   1      
 260   1              beginSend();
 261   1      }
 262          
 263          void presetSingleRegister(void)         //设置单个寄存器
 264          {
 265   1              U8 addr;
 266   1              U8 tempAddr;
 267   1              U8 setCount;
 268   1              U16 crcData;
 269   1              U16 tempData;
 270   1      
 271   1              //addr = (receBuf[2]<<8) + receBuf[3];
 272   1              //tempAddr = addr & 0xfff;
 273   1              addr = receBuf[3];
 274   1              tempAddr = addr;                //& 0xff
 275   1      
 276   1              tempData = ( receBuf[4]<<8 ) + receBuf[5];
 277   1              setRegisterVal(tempAddr,tempData);
 278   1      
 279   1              sendBuf[0] = localAddr;
 280   1              sendBuf[1] = 6;
 281   1              sendBuf[2] = addr >> 8;
 282   1              sendBuf[3] = addr & 0xff;
 283   1              sendBuf[4] = receBuf[4];
 284   1              sendBuf[5] = receBuf[5] ;
 285   1      
 286   1              setCount = 6;           //共6个字节
 287   1              crcData = crc16(sendBuf,6);
 288   1              sendBuf[6] = crcData >> 8;
 289   1              sendBuf[7] = crcData & 0xff;
 290   1      
 291   1              sendCount = 8;
 292   1              beginSend();
 293   1      }
 294          
 295          //设置多个寄存器
 296          void presetMultipleRegisters(void)
 297          {
 298   1              UINT8 addr;
 299   1              UINT8 tempAddr;
 300   1              UINT8 byteCount;
 301   1              UINT8 setCount;
 302   1              UINT16 crcData;
 303   1              UINT16 tempData;
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 6   

 304   1              UINT8 i;
 305   1      
 306   1              //addr = (receBuf[2]<<8) + receBuf[3];
 307   1              //tempAddr = addr & 0xfff;
 308   1              addr = receBuf[3];
 309   1              tempAddr = addr & 0xff;
 310   1      
 311   1              //setCount = (receBuf[4]<<8) + receBuf[5];
 312   1              setCount = receBuf[5];
 313   1              byteCount = receBuf[6];
 314   1      
 315   1              for (i = 0; i < setCount; i++, tempAddr++) {
 316   2                      //SBUF = receBuf[i*2+7];
 317   2                      //SBUF = receBuf[i*2+8];
 318   2                      tempData = (receBuf[i*2+7] << 8) + receBuf[i*2+8];
 319   2      
 320   2                      setRegisterVal(tempAddr, tempData);
 321   2              }
 322   1      
 323   1              sendBuf[0] = localAddr;
 324   1              sendBuf[1] = 16;
 325   1              sendBuf[2] = addr >> 8;
 326   1              sendBuf[3] = addr & 0xff;
 327   1              sendBuf[4] = setCount >> 8;
 328   1              sendBuf[5] = setCount & 0xff;
 329   1              crcData = crc16(sendBuf, 6);
 330   1              sendBuf[6] = crcData >> 8;
 331   1              sendBuf[7] = crcData & 0xff;
 332   1              sendCount = 8;
 333   1      
 334   1              beginSend();
 335   1      }
 336          
 337          //取线圈状态 返回0表示成功
 338          UINT16 getCoilVal(UINT16 addr, UINT16 *tempData)
 339          {
 340   1              UINT16 result = 0;
 341   1              UINT16 tempAddr;
 342   1              tempAddr = addr & 0xfff;
 343   1              //只取低8位地址
 344   1              switch( tempAddr )              //只取低8位地址 & 0xff
 345   1              {
 346   2                      case 0:
 347   2                                      if (P1&0x01)
 348   2                                              *tempData = 0;
 349   2                                      else
 350   2                                              *tempData = 1;
 351   2                                      break;
 352   2                      case 1:
 353   2                                      if (P1&0x02)
 354   2                                              *tempData = 0;
 355   2                                      else
 356   2                                              *tempData = 1;
 357   2                                      break;
 358   2      
 359   2                      case 2:
 360   2                                      if (P1&0x04)
 361   2                                              *tempData = 0;
 362   2                                      else
 363   2                                              *tempData = 1;
 364   2      
 365   2                                      break;
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 7   

 366   2      
 367   2                      case 3:
 368   2                                      if (P1&0x08)
 369   2                                              *tempData = 0;
 370   2                                      else
 371   2                                              *tempData = 1;
 372   2                                      break;
 373   2      
 374   2                      case 4:
 375   2                                      if (P1&0x10)
 376   2                                              *tempData = 0;
 377   2                                      else
 378   2                                              *tempData = 1;
 379   2                                      break;
 380   2      
 381   2                      case 5:
 382   2                                      if (P1&0x20)
 383   2                                              *tempData = 0;
 384   2                                      else
 385   2                                              *tempData = 1;
 386   2                                      break;
 387   2      
 388   2                      case 6:
 389   2                                      if (P1&0x40)
 390   2                                              *tempData = 0;
 391   2                                      else
 392   2                                              *tempData = 1;
 393   2                                      break;
 394   2      
 395   2                      case 7:
 396   2                                      if (P1&0x80)
 397   2                                              *tempData = 0;
 398   2                                      else
 399   2                                              *tempData = 1;
 400   2                                      break;
 401   2                      case 8:
 402   2                                      break;
 403   2                      case 9:
 404   2                                      break;
 405   2      
 406   2                      case 10:
 407   2                                      if (KEY0)
 408   2                                              *tempData = 0;                                                      
 409   2                                      else
 410   2                                              *tempData = 1;
 411   2                                      break;
 412   2      
 413   2                      case 11:
 414   2                                      if (KEY1)       
 415   2                                              *tempData = 0;
 416   2                                      else 
 417   2                                              *tempData = 1;
 418   2      
 419   2                                                                      
 420   2                                      break;
 421   2                      case 12:
 422   2                                      break;
 423   2                      case 13:
 424   2                                      break;
 425   2                      case 14:
 426   2                                      break;
 427   2                      case 15:
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 8   

 428   2                                      break;
 429   2                      default:
 430   2                                      break;
 431   2              }
 432   1      
 433   1              return result;
 434   1      }
 435          
 436          //设定线圈状态 返回0表示成功
 437          UINT16 setCoilVal(UINT16 addr, UINT16 tempData)
 438          {
 439   1              UINT16 result = 0;
 440   1              UINT16 tempAddr;
 441   1              static UINT8  flag_led;
 442   1              tempAddr = addr & 0xfff;
 443   1              switch(tempAddr)                // & 0xff
 444   1              {
 445   2      //              case 0:
 446   2      //                              if (tempData)
 447   2      //                                      LED0 =0;
 448   2      //                              else
 449   2      //                                      LED0 = _cror_(P1,1)&0x01;
 450   2      //                              break;
 451   2      //              case 1:
 452   2      //                              if (tempData)
 453   2      //                                      LED1 = 0;
 454   2      //                              else
 455   2      //                                      LED1 = _cror_(P1,1)&0x02;
 456   2      //                              break;
 457   2      //              case 2:
 458   2      //                              if (tempData)
 459   2      //                                      LED2 = 0;
 460   2      //                              else
 461   2      //                                      LED2 = _cror_(P1,1)&0x04;
 462   2      //                              break;
 463   2      //              case 3:
 464   2      //                              if (tempData)
 465   2      //                                      LED3 = 0;
 466   2      //                              else
 467   2      //                                      LED3 = _cror_(P1,1)&0x80;
 468   2      //                              break;
 469   2      //              case 4:
 470   2      //                              if (tempData)
 471   2      //                                      LED4 = 0;
 472   2      //                              else
 473   2      //                                      LED4 = _cror_(P1,1)&0x10;
 474   2      //                              break;
 475   2      //              case 5:
 476   2      //                              if (tempData)
 477   2      //                                      LED5 = 0;
 478   2      //                              else
 479   2      //                                      LED5 = _cror_(P1,1)&0x20;
 480   2      //                              break;
 481   2      //              case 6:
 482   2      //                              if (tempData)
 483   2      //                                      LED6 = 0;
 484   2      //                              else
 485   2      //                                      LED6 = _cror_(P1,1)&0x40;
 486   2      //                              break;
 487   2      //              case 7:
 488   2      //                              if (tempData)
 489   2      //                                      LED7 = 0;
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 9   

 490   2      //                              else
 491   2      //                                      LED7 = _cror_(P1,1)&0x80;
 492   2      //                              break;
 493   2             case 8:  
 494   2                                      if (tempData)                                             // tempData    灯状态
 495   2                                      {
 496   3                                              P1=_crol_(P1,2);
 497   3                                       }                                                          
 498   2                                      else
 499   2                                       {
 500   3                                              P1=_cror_(P1,2);
 501   3                                       }
 502   2                                              break;           
 503   2                      case 9:                         
 504   2                                      while (tempData==1)
 505   2                                      {       
 506   3      
 507   3                                              P1=~P1; 
 508   3                                      }       
 509   2                                      
 510   2                                      
 511   2                                                                                                                                                                              /*              if ((tempData==0)&&(flag_led==1))       
 512   2                                                                                                                                                                                               {
 513   2                                                                                                                                                                                                      flag_led=0;
 514   2                                                                                                                                                                                                      P1=~P1;
 515   2                                                                                                                                                                                               }
 516   2                                                                                                                                                                                              else if((tempData==0)&&(flag_led==0))
 517   2                                                                                                                                                                                              {       
 518   2                                                                                                                                                                                                      
 519   2                                                                                                                                                                                                      flag_led=0;     
 520   2                                                                                                                                                              
 521   2                                                                                                                                                                                              }
 522   2                                                                                                                                                                                              else if((tempData==1)&&(flag_led==0))
 523   2                                                                                                                                                                                              {       
 524   2                                                                                                                                                                                                      
 525   2                                                                                                                                                                                                      flag_led=1;
 526   2                                                                                                                                                                                                      P1=~P1; 
 527   2                                                                                                                                                              
 528   2                                                                                                                                                                                              }
 529   2                                                                                                                                                                                              else if((tempData==1)&&(flag_led==1))
 530   2                                                                                                                                                                                              {       
 531   2                                                                                                                                                                                                      
 532   2                                                                                                                                                                                                      flag_led=1;        
 533   2                                                                                                                                                                                              }
 534   2                                                                                                                                                                                              break;          */              
 535   2      /*              case 10:
 536   2                                      if ((tempData==0)&&(flag_led==1))       
 537   2                                       {
 538   2                                              flag_led=0;
 539   2                                              P1=~P1;
 540   2                                       }
 541   2                                      else if((tempData==0)&&(flag_led==0))
 542   2                                      {       
 543   2                                              
 544   2                                              flag_led=0;     
 545   2      
 546   2                                      }
 547   2                                      else if((tempData==1)&&(flag_led==0))
 548   2                                      {       
 549   2                                              
 550   2                                              flag_led=1;
 551   2                                              P1=~P1; 
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 10  

 552   2      
 553   2                                      }
 554   2                                      else if((tempData==1)&&(flag_led==1))
 555   2                                      {       
 556   2                                              
 557   2                                              flag_led=1;     
 558   2                                      }
 559   2                                      break;                                   */
 560   2      
 561   2                      case 11:
 562   2                                      break;
 563   2      //              case 12:
 564   2      //                              break;
 565   2      //              case 13:
 566   2      //                              break;
 567   2      //              case 14:
 568   2      //                              break;
 569   2      //              case 15:
 570   2      //                              break;
 571   2      //              case 16:
 572   2      //                              break;
 573   2      //              case 17:
 574   2      //                              break;
 575   2      //
 576   2                      default:
 577   2                                      break;
 578   2              }
 579   1      
 580   1              return result;
 581   1      }
*** WARNING C280 IN LINE 441 OF MODBUS.C: 'flag_led': unreferenced local variable
 582          
 583          //取寄存器值 返回0表示成功
 584          UINT16 getRegisterVal(UINT16 addr, UINT16 *tempData)
 585          {
 586   1              UINT16 result = 0;
 587   1              UINT16 tempAddr;
 588   1      
 589   1              tempAddr = addr & 0xfff;
 590   1      
 591   1              switch(tempAddr)        //& 0xff
 592   1              {
 593   2      
 594   2                      case 0:
 595   2                              *tempData = testRegister0;
 596   2                              break;
 597   2                      case 1:
 598   2                              *tempData = testRegister1;
 599   2                              break;
 600   2                      case 2:
 601   2                              *tempData = testRegister2;
 602   2                              break;
 603   2                      case 3:
 604   2                      //testRegister3= sdate;
 605   2                              
 606   2                              *tempData = testRegister3;
 607   2                              
 608   2                              break;
 609   2                      case 4:
 610   2                              *tempData = testRegister4;
 611   2                              break;    
 612   2                      case 5:
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 11  

 613   2                              *tempData = testRegister5;
 614   2                              break;
 615   2                      case 6:
 616   2                              *tempData = testRegister6;
 617   2                              break;
 618   2                      case 7:
 619   2                              *tempData = testRegister7;
 620   2                              break;
 621   2                      case 8:
 622   2                              *tempData = testRegister8;
 623   2                              break;
 624   2                      case 9:
 625   2                              *tempData = testRegister9;
 626   2                              break;
 627   2                      case 10: 
 628   2                              break;
 629   2                      case 11:
 630   2                              break;
 631   2                      case 12:
 632   2                              break;
 633   2                      case 13:
 634   2                              break;
 635   2                      case 14:
 636   2                              break;
 637   2                      case 15:
 638   2                              break;
 639   2                      case 16:
 640   2                              break;
 641   2                      default:
 642   2                              break;
 643   2              }
 644   1      
 645   1              return result;
 646   1      }
 647          
 648          //设置寄存器值 返回0表示成功
 649          UINT16 setRegisterVal(UINT16 addr, UINT16 tempData)
 650          {
 651   1              UINT16 result = 0;
 652   1              UINT16 tempAddr;
 653   1      
 654   1              tempAddr = addr & 0xfff;
 655   1      
 656   1              switch(tempAddr)        //& 0xff
 657   1              {
 658   2                      case 0:
 659   2                              testRegister0 = tempData;
 660   2                              break;
 661   2                      case 1:
 662   2                              testRegister1 = tempData;
 663   2                              break;
 664   2                      case 2:
 665   2                              testRegister2 = tempData;
 666   2                              break;
 667   2                      case 3:
 668   2                              testRegister3 = tempData;
 669   2                              
 670   2                              break;
 671   2                      case 4:
 672   2                              testRegister4 = tempData;
 673   2                  //P1=tempData ; //&& 0X00FF
 674   2                              break;
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 12  

 675   2                      case 5:
 676   2                              testRegister5 = tempData;
 677   2                              break;
 678   2                      case 6:
 679   2                              testRegister6 = tempData;
 680   2                              break;
 681   2                      case 7:
 682   2                              testRegister7 = tempData;
 683   2                              break;
 684   2                      case 8:
 685   2                              testRegister8 = tempData;
 686   2                              break;
 687   2                      case 9:
 688   2                              testRegister9 = tempData;
 689   2                              break;
 690   2                      case 10:
 691   2                              break;
 692   2                      case 11:
 693   2                              break;
 694   2                      case 12:
 695   2                              break;
 696   2                      case 13:
 697   2                              break;
 698   2                      case 14:
 699   2                              break;
 700   2                      case 15:
 701   2                              break;
 702   2                      case 16:
 703   2                              break;
 704   2                      default:
 705   2                              break;
 706   2              }
 707   1      
 708   1              return result;
 709   1      }
 710          
 711          void ModbusDelay (unsigned int nDelay)
 712          {
 713   1              volatile unsigned int i, j;
 714   1              
 715   1              for (i = 0; i < nDelay; i ++)
 716   1                      for (j = 0; j < 10; j ++);
 717   1      }
 718          
 719          //检查uart0数据
 720          void checkComm0Modbus(void)
 721          {
 722   1              UINT16 crcData;
 723   1              UINT16 tempData;
 724   1      
 725   1              if (receCount > 4) {
 726   2                      switch (receBuf[1]) {
 727   3                              case 1://读取线圈状态(读取点 16位以内)
 728   3                              case 3://读取保持寄存器(一个或多个)
 729   3                              case 5://强制单个线圈
 730   3                              case 6://设置单个寄存器
 731   3                                      if (receCount >= 8) {
 732   4                                              //接收完成一组数据
 733   4                                              //应该关闭接收中断
 734   4                                              UART_DISABLE_INTERRUPT();
 735   4      
 736   4                                              if (receBuf[0] == localAddr) {
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 13  

 737   5                                                      ModbusDelay (10);
 738   5      
 739   5                                                      crcData = crc16(receBuf, 6);
 740   5                                                      if (crcData == receBuf[7] + (receBuf[6] << 8)) {
 741   6                                                              //校验正确
 742   6                                                              if (receBuf[1] == 1) {
 743   7                                                                      //读取线圈状态(读取点 16位以内)
 744   7                                                                      readCoil();
 745   7                                                              }
 746   6                                 
 747   6                                                              else if (receBuf[1] == 3) {
 748   7                                                                      //读取保持寄存器(一个或多个)
 749   7                                                                      readRegisters();
 750   7                                                              }
 751   6                                                              else if (receBuf[1] == 5) {
 752   7                                                                      //强制单个线圈
 753   7                                                                      forceSingleCoil();
 754   7                                                              }
 755   6                                                              else if (receBuf[1] == 6) {
 756   7                                                                      //写单个寄存器
 757   7                                                                      presetSingleRegister();
 758   7                                                              }
 759   6                                                      }
 760   5                                              }
 761   4      
 762   4                                              RI = 0;
 763   4                                              receCount = 0;
 764   4      
 765   4                                              UART_ENABLE_INTERRUPT();
 766   4                                      }
 767   3                                      break;
 768   3                              case 15://设置多个线圈
 769   3                                      tempData = receBuf[6];
 770   3                                      tempData += 9;  //数据个数
 771   3                                      if (receCount >= tempData) {
 772   4                                              if (receBuf[0] == localAddr) {
 773   5                                                      crcData = crc16(receBuf, tempData - 2);
 774   5                                                      if (crcData == (receBuf[tempData-2] << 8) + receBuf[tempData-1]) {
 775   6                                                              //forceMultipleCoils();
 776   6                                                      }
 777   5                                              }
 778   4                                              receCount = 0;
 779   4                                      }
 780   3                                      break;
 781   3                              case 16://设置多个寄存器
 782   3                                      tempData = (receBuf[4] << 8) + receBuf[5];
 783   3                                      tempData = tempData * 2;    //数据个数
 784   3                                      tempData += 9;
 785   3      
 786   3                                      if (receCount >= tempData) {
 787   4      
 788   4                                              UART_DISABLE_INTERRUPT();
 789   4      
 790   4                                              if (receBuf[0] == localAddr) {
 791   5                                                      crcData = crc16(receBuf, tempData - 2);
 792   5                                                      if (crcData == (receBuf[tempData-2] << 8) + receBuf[tempData-1]) {
 793   6                                                              presetMultipleRegisters();
 794   6                                                      }
 795   5                                              }
 796   4                                              RI = 0;
 797   4                                              receCount = 0;
 798   4      
C51 COMPILER V9.02   MODBUS                                                                07/03/2017 17:56:35 PAGE 14  

 799   4                                              UART_ENABLE_INTERRUPT();
 800   4                                      }
 801   3                                      break;
 802   3                              default:
 803   3                                      break;
 804   3                      }
 805   2              }
 806   1              
 807   1              
 808   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1525    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      51
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
